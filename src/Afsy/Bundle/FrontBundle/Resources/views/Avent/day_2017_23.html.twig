{% extends 'AfsyFrontBundle:Avent:day.html.twig' %}

{% set year = 2017 %}

{% block article_title "Jour 23 - Comment l’architecture hexagonale nous a facilité la vie !" %}

{% block article_content %}
    <h1>Comment l’architecture hexagonale nous a facilité la vie !</h1>

    <h2>Commençons le projet</h2>
    <p>
        Nouveau projet, nouvelle équipe et nouveau client pour moi.
        Comme d’habitude j’ai hâte de commencer le projet et de connaître ce client pour qui je n’ai jamais travaillé.
        Je commence à faire mon enquête pour me faire une vague idée sur ce client qui m’est inconnu.
    </p>
    <p>
    <ul>
        <li>« Oh le client est bien, mais pas trop habitué au mode agile. »</li>
        <li>« C’est un client avec des méthodes de travail un peu à l’ancienne »</li>
        <li>« Tu vas voir il faut s’appuyer sur des Web Service (WS) SOAP bien sympathiques »</li>
        <li>« Leur plateforme de dev n’est pas très stable, parfois on ne peut plus utiliser les WS de dev, car ils ne sont plus disponibles. »</li>
    </ul>
    </p>

    <p>
        Et j’en passe…
    </p>

    <p>
        Vous vous imaginez-bien que même avant de commencer je me suis dis, ça va être drôle, je sens qu’on va bien s’amuser !
    </p>

    <p>
        <strong>Problème principal :</strong>
        trouver un outil qui nous permette de transformer les WS SOAP et leurs méthodes en langage objet.
        Ça tombe bien, une petite librairie PHP nous permet d’effectuer une génération de classe à partir des WSDL (langage qui permet de décrire l'emplacement d'un service web ainsi que ses opérations),
        Génial !! Problème résolu, YES !
    </p>
    <p>
        <strong>Second problème (celui qui nous intéresse aujourd'hui) :</strong>
        comment pouvons-nous travailler sans dépendre de leur « super » WS SOAP ?
    </p>
    <p>
        C'est là que nous avons l'idée de mettre en place une architecture hexagonale,
        car ça va nous permettre de détacher tout ce qui est métier de l’infrastructure et ainsi on pourra utiliser soit les WS SOAP,
        soit une autre source de données (SQLite pour nous).
    </p>

    <h2>Comment avons nous utilisé ce principe d’architecture hexagonale ?</h2>
    <p>
        Voici l'article que nous avons utilisé comme point d'entrée, dans notre démarche :
        <a href="http://blog.xebia.fr/2016/03/16/perennisez-votre-metier-avec-larchitecture-hexagonale/">Pérennisez votre métier avec l'architecture hexagonale</a>
    </p>

    <p align="center">
        Principe schématisé
        <img src="{{ asset('bundles/afsyfront/images/avent/23-archi-hexagonale.png') }}" alt="Architecture hexagonale" />
        (source :
            <a href="http://blog.xebia.fr/2016/03/16/perennisez-votre-metier-avec-larchitecture-hexagonale/">
                http://blog.xebia.fr/2016/03/16/perennisez-votre-metier-avec-larchitecture-hexagonale/
            </a>
        )
    </p>

    <p>
        Concrètement nous avons toute notre partie métier, qui possède la logique de l'application, ce qu'elle doit faire exactement.
        Autour de laquelle nous pouvons connecter une API, une BDD, un service de cache, ...
    </p>
    <p>
        Tous les services ne doivent en aucun cas impacter la logique métier, donc il faut faire en sorte que tous soient un maximum indépendant.
        Pour ce faire nous allons créer des interfaces permettant aux adaptateurs des différents services de se brancher aux métiers sans l'impacter.
        Avec cette architecture nous pourrons ajouter n'importe quel service pour traiter nos données (repository, persister) sans qu'il y ait d'impact sur le métier !
        Voici le découpage de notre application dans le répertoire /src  :
    </p>

    <code>
        <ul style="list-style: none">
            <li>src</li>
            <li>├── AppBundle</li>
            <li>│   ├── AppBundle.php</li>
            <li>│   ├── Command</li>
            <li>│   ├── Component</li>
            <li>│   ├── Controller</li>
            <li>│   ├── DependencyInjection</li>
            <li>│   ├── Dictionary</li>
            <li>│   ├── Doctrine</li>
            <li>│   ├── Event</li>
            <li>│   ├── Exception</li>
            <li>│   ├── Form</li>
            <li>│   ├── Http</li>
            <li>│   ├── Monolog</li>
            <li>│   ├── Provider</li>
            <li>│   ├── Repository</li>
            <li>│   ├── Resources</li>
            <li>│   ├── Response</li>
            <li>│   ├── Security</li>
            <li>│   ├── Sort</li>
            <li>│   ├── Transformer</li>
            <li>│   ├── Twig</li>
            <li>│   ├── Validator</li>
            <li>│   └── Webview</li>
            <li>├── Domain</li>
            <li>│   ├── Model</li>
            <li>│   ├── Persister</li>
            <li>│   └── Repository</li>
            <li>└── Infrastructure</li>
            <li>├── Cache</li>
            <li>├── Doctrine</li>
            <li>├── Sqlite</li>
            <li>└── Webservice</li>
        </ul>
    </code>

    <p>
        <ul>
            <li>
                <strong>/AppBundle :</strong> Code symfony
                <ul>
                    <li><strong>/Provider :</strong> Services faisant le lien entre les Repository et les services sf (ex. token_storage)</li>
                </ul>
            </li>
            <li>
                <strong>/Domain :</strong>Contient une abstraction du métier
                <ul>
                    <li><strong>/Model:</strong> Représente les modèles de données utilisés sur l’application</li>
                    <li><strong>/Persister:</strong> Interface définissant comment les modèles sont sauvegardés</li>
                    <li><strong>/Repository:</strong> Interface définissant comment les modèles sont récupérés</li>
                </ul>
            </li>
            <li><strong>/Infrastructure :</strong> Contient les implémentations des interfaces du répertoire /Domain</li>
        </ul>
    </p>

    <p>
        Voici notre démarche de développement pour chaque nouvelle fonctionnalités :
    </p>
    <p>
        <ul>
            <li>Création des modèles.</li>
            <li>Création des interfaces persister et repository. Notre politique est de créer uniquement ce dont on a besoin. Si nous avons simplement besoin de récupérer les données, on ne crée qu’un repository et vice-versa.</li>
            <li>Développement de la partie SQLite (persister / repository) pour valider le côté fonctionnel de l'application.</li>
            <li>Création des test fonctionnels (behat dans notre cas) pour valider que tout fonctionne.</li>
            <li>Création des tests unitaire.</li>
            <li>Si tout est ok en SQLite, développement des adapteurs pour la partie Webservice.</li>
            <li>Si besoin, développement d'adaptateurs de cache nous permettant de créer le cache et de l'utiliser à la place des Webservice.</li>
        </ul>
    </p>

    <p>Voici à quoi peut ressembler notre application aujourd'hui :</p>

    <p align="center">
        Pour les repository (lecture des données)
        <img src="{{ asset('') }}" alt="persister" />
    </p>

    <p align="center">
        Pour les persister (écriture des données)
        <img src="{{ asset('bundles/afsyfront/images/avent/23-archi-hexagonale-persister.png') }}" alt="persister" />
    </p>

    <p align="center">
        (source : schéma déssinés par <a href="https://github.com/melicerte">@melicerte</a>)
    p>
    <h2>Et pourquoi on ne verrai pas un exemple</h2>

    <p>Nous allons ajouter la possibilité de lire un article de blog.</p>

    <ul>
        <li>
            D'abord nous allons créer un model Article, avec un titre et un contenu.

            <pre class="language-php">
                <code>
namespace AppBundle\Domain\Model;

class Article
{
    /** @var string */
    private $title;

    /** @var string */
    private $content;

    /**
    * @param string $title
    * @param string $content
    */
    public function __construct($title, $content)
    {
        $this->title = $title;
        $this->content = $content;
    }

    /**
    * @return string
    */
    public function getTitle()
    {
        return $this->title;
    }

    /**
    * @param string $title
    */
    public function setTitle($title)
    {
        $this->title = $title;
    }

    /**
    * @return string
    */
    public function getContent()
    {
        return $this->content;
    }

    /**
    * @param string $content
    */
    public function setContent($content)
    {
        $this->content = $content;
    }
}

                </code>
            </pre>
        </li>

        <p>
            <p>Création de l'interfaces pour le repository, car nous souhaitons lire le contenu d'un article.</p>
            <pre class="language-php">
                <code>
namespace AppBundle\Domain\Repository;

use AppBundle\Domain\Model;

interface Article
{
   /**
    * @param string $title
    *
    * @return Model\Article
    */
   public function getArticleByTitle(string $title): Model\Article;
}

                </code>
            </pre>
        </li>
        <li>
            Création du repository SQLite

            <pre class="language-php">
                <code>
namespace AppBundle\Infrastructure\Sqlite\Repository;

use Doctrine\DBAL\Connection;
use AppBundle\Domain\Model;
use AppBundle\Domain\Repository;

class Article implements Repository\Article
{
    /** @var Connection */
    private $connection;

    /**
     * @param Connection      $connection
     * @param Hydrator\Agency $hydrator
     */
    public function __construct(Connection $connection, Hydrator\Agency $hydrator)
    {
        $this->connection = $connection;
    }

    /**
     * {@inheritdoc}
     */
    public function getArticleByTitle(string $title): Model\Article
    {
        $qb = $this->connection->createQueryBuilder();

        $result = $qb
            ->select('a.*')
            ->from('article', 'a')
            ->where('a.title = :title')
            ->setParameter('title', $title)
            ->execute()
            ->fetch()
        ;

        if ($result === false) {
            throw new UserNotFoundException('Cette article n\'existe pas.');
        }

        return $this->hydrator->hydrate($result);
    }
}

                </code>
            </pre>

        </li>
        <li>
            Création du repository avec les WS SOAP
            <pre class="language-php">
                <code>
namespace AppBundle\Infrastructure\Webservice\Repository;

use AppBundle\Webservice\Article\ArticleService;
use AppBundle\Domain\Model;
use AppBundle\Domain\Repository;
use AppBundle\Infrastructure\Webservice\RequestBuilder\LireArticle;

class Agency implements Repository\Agency
{
    /** @var ArticleService */
    private $articleService;

    /** @var LireArticle */
    private $requestBuilder;

    /**
     * @param ArticleService   $articleService
     * @param LireArticle      $requestBuilder
     */
    public function __construct(
        $articleService,
        LireArticle $requestBuilder
    ) {
        $this->articleService  = $articleService;
        $this->requestBuilder = $requestBuilder;
    }

    /**
     * {@inheritdoc}
     */
    public function getArticleByTitle(string $title): Model\Article
    {
        $request  = $this->requestBuilder->build($title);
        $response = $this->articleService->lireArticle($request);

        return $response;
    }
}
                </code>
            </pre>
        </li>
    </ul>

    <p>
        Chaque service utilisé a sa propre manière d'aller chercher l'information, mais le métier, lui doit seulement utiliser la méthode
        <code>getArticleByTitle</code>. Donc, pour n'importe quel service utilisé la façon de récupérer les données pour la partie métier reste la même.
    </p>

    <h2>Et aujourd'hui ça donne quoi ?</h2>

    <p>
        Alors, comment je peux affirmer que cette architecture m'a facilité la vie.
        Et bien on s'est parfois retrouvé avec des WS down toute une journée, alors que nous étions uniquement sur ce projet.
        Du coup la partie SQLite nous a permis d'avancer sans s'arrêter, pas de pause dans le projet.
    </p>

    <p>
        Une partie métier bien maitrisé, on a pu vraiment se concentrer sur les fonctionnalités désirées par le client.
        Et cette architecture nous a permis de certifier au client que toute la partie métier n'aura pas à être modifiée s'il décide de passer des WS SOAP à une API REST par exemple.
        Et oui, nous n'aurons que les adaptateurs à ajouter, elle est pas belle la vie ?!
    </p>

    <p>
        Pour les nouvelles personnes arrivant sur le projet il est vrai que ce n'est pas tout simple,
        mais dès qu'ils ont le projet en mains ça roule plutôt pas mal !
        Voici pour preuve le petit témoignage d'un de mes collègues qui a du travailler sur le projet alors que tout était déjà en place :
        <p>
            "C'est très dur de comprendre l'architecture quand on débarque sur le projet.
            Mais après tu vois et comprends pourquoi c'est fait comme ça, et tu te dis : Ah oui c'est pas mal au final"
        </p>
    </p>

    <p>
        Malgré les bons cotés de ce style d'architecture je ne pense pas qu'il soit la solution à tous les problèmes.
        Comme pour tous projets il faut bien sûr réfléchir à ce qui convient le mieux aux besoins et aux contraintes clients.
    </p>


{% endblock %}

{% block article_avatar %}
    <img src="{{ asset('bundles/afsyfront/images/avent/23-celine-morin.jpg') }}" alt="Céline Morin" />
{% endblock %}

{% block article_bio %}
    <h2>
        <a href="{% block author_url %}https://twitter.com/Titi_Celine{% endblock %}" target="_blank">
            {% block article_author %}Céline Morin{% endblock %}
        </a>
    </h2>
    <p>
        Développeuse Back-end Symfony chez
        <a target="_blank" href="//biig.fr">BiiG</a>.
    </p>
{% endblock %}
